#!/usr/bin/env python

# Imported libraries
import sys
from sys import stdout

# Constants for the virtual memory program
FIFO = 0
LRU = 1
OPT = 2
MAX_TLB = 16
MAX_PAGES = 256
FRAMES = 256
CONTENT_SIZE = 256
DEFAULT_SCHED = 'FIFO'
MASK = 255
BYTE = 8
BACKING_STORE = 'BACKING_STORE.bin'

# The following will be classes that will be used in this code

# This is a basic page class that will be used as the simple structure
# that we can pass into other classes
class Page:
   def __init__(self):
      self.id = -1
      self.frame = -1
      self.used = 0
      self.loaded = False
   def setFrame(self, frame):
      self.frame = frame
      self.loaded = True
   def unLoad(self):
      self.loaded = False

# This is the translation lookaside buffer and will hold only 16 spots
# for incomming pages
class TLB:
   def __init__(self, sched):
      self.table = [Page()] * MAX_TLB
      self.nextIndex = 0
      self.hits = 0
      self.misses = 0
      self.sched = sched

   def lookup(self, id):
      status = False

      for entry in self.table:
         if entry.id == id:
            status = True
            self.hits += 1

      return status

   def add(self, page):
      self.misses += 1

      if self.sched == FIFO:
         self.table[self.nextIndex] = page

         if self.nextIndex == MAX_TLB - 1:
            self.nextIndex = 0
         else:
            self.nextIndex += 1

   def getFrame(self, id):
      frame = -1

      for entry in xrange(MAX_TLB):
         if self.table[entry].id == id:
            frame = self.table[entry].frame

      return frame

# All the pages are to be held in this data structure. Will not have
# pages initialized in the beginning. They have to be added in
class PageTable:
   def __init__(self):
      self.table = [Page()] * MAX_PAGES
      self.faults = 0

   def add(self, page):
      self.table[page.id] = page
      self.faults += 1

   def lookup(self, pageID):
      status = False

      if self.table[pageID].id is not -1:
         status = True

      return status

   def getPage(self, pageID):
      return self.table[pageID]

# This will act as actual physical memory and have content or data in
# the frames to be accessed
class PhysicalMem:
   def __init__(self, sched, frames):
      self.table = [0] * int(frames)
      self.sched = sched
      self.maxFrames = int(frames)
      self.currentFrame = 0
      self.nextFrame = 0

   def add(self, content):
      if self.sched == FIFO:
         self.table[self.nextFrame] = content
         self.currentFrame = self.nextFrame

         if self.nextFrame == self.maxFrames - 1:
            self.nextFrame = 0
         else:
            self.nextFrame += 1

   def get(self, index):
      return self.table[index]

# This function takes arguments in and returns them in a format we can use.
# This assumes that all args are in the correct position
def ReturnArgs(args):
   filename = ''
   frames = FRAMES
   pra = DEFAULT_SCHED

   if len(args) > 0:
      filename = args[0]

      if len(args) == 3:
         frames = args[1]
         pra = args[2]
      elif len(args) == 2:
         if args[1].isdigit():
            frames = args[1]
         else:
            pra = args[1]

   return (filename, frames, pra)

# Opens the file passed in with a try except method. Takes all the data
# from that file and closes it.
# This also opens the backing store file
def OpenFiles(logAddress, filename):
   try:
      with open(filename, 'r') as file:
         for line in file:
            logAddress.append(int(line))

      file.close()
   except IOError as e:
      print 'I/O error, file does not exist'
      sys.exit()

   binFile = open(BACKING_STORE)

   return binFile

# Sets the scheduling type for physical memory and the tlb
def SetSched(pra):
   sched = FIFO

   if pra.upper() == 'LRU':
      sched = LRU
   elif pra.upper() == 'OPT':
      sched = OPT

   return sched

# Gets the page info as well as the offset of an address
def GetInfo(address):
   page = (MASK << BYTE & address) >> BYTE
   offset = MASK & address

   return (page, offset)

# Looks at a 256 byte hex value and gets the byte located at the offset
# Prints in signed 8 bit integer
def GetValue(content, offset):
   decoded = content.decode('hex')  # Transformes a hex value to be readable as a decimal
   value = ord(decoded[offset])  # Gets the byte from the specified offset

   # This makes sure that the output can be viewed as a 8 bit signed integer
   if value >= (CONTENT_SIZE / 2):
      value = value - CONTENT_SIZE

   return value

# Gets a 256 byte value from the backing store
def GetContent(binFile, page):
   position = page * CONTENT_SIZE
   file = binFile
   file.seek(position)
   content = file.read(256)
   content = content.encode('hex').upper()
   return content

# Prints the data of the code to stdout
def PrintData(pageTable, tlb, length):
   faults = pageTable.faults

   print('Number of Translated Addresses = %d' %length)
   print('Page Faults = %d' %faults)
   print('Page Fault Rate = %.3f' %(float(faults) / float(length)))
   print('TLB Hits = %d' %(tlb.hits))
   print('TLB Misses = %d' %(tlb.misses))
   print('TLB Hit Rate = %.3f' %(float(tlb.hits) / (float(tlb.hits) + float(tlb.misses))))

# Main function of the code. Will drive the functions in order to complete
# the fake virtual memory code
def main():
   args = sys.argv[1:]  # This will have all the arguments that we will use
   logAddress = []      # Will have all logical addresses
   filename, frames, pra = ReturnArgs(args)  # Gives us all the arguments
   binFile = OpenFiles(logAddress, filename) # Moves file contents to logAddress and opens backing store

   sched = SetSched(pra)   # Sets the schedule. We will use for tlb and physical mem
   buffer = TLB(sched)     # Sets up the TLB
   pageTable = PageTable() # Sets up the page table
   physicalMem = PhysicalMem(sched, frames)  # Sets up physical memory

   # Goes through all the logical addresses, Virtual Memory to Physical Memory part of the main
   for address in logAddress:
      pageID, offset = GetInfo(address)   # Gets the page and offset from the logical address
      newPage = Page()
      newPage.id = pageID
      frameNum = physicalMem.nextFrame    # Value will never get used. Put here to handle an error

      # First checks to see if in the buffer to set frame
      if not(buffer.lookup(pageID)):
         # If not in the buffer checks to see if page is in the pageTable. Adds to buffer if yes
         if pageTable.lookup(pageID):
            pageTemp = pageTable.getPage(pageID)
            buffer.add(pageTemp)
         # Adds page to TLB and pagetable if not found. Then ands to pysical memory
         else:
            newPage.setFrame(physicalMem.nextFrame)   # Based on the scheduling algorithm set new frame
            buffer.add(newPage)
            pageTable.add(newPage)
            physicalMem.add(GetContent(binFile, pageID))
      else:
         frameNum = buffer.getFrame(pageID)  # To access physical memory framenumber

      frameNum = buffer.getFrame(pageID)  # Could be accessed through other means but this supports
                                          # and mimics how virtual memory really moves around
      # The following just prints out necessary information for each logical address
      stdout.write('%d, ' %address)
      stdout.write('%d, ' %GetValue(physicalMem.get(frameNum), offset))
      stdout.write('%d, ' %frameNum)
      stdout.write(physicalMem.get(frameNum))
      stdout.write('\n')
      stdout.flush()

   binFile.close()   # Now that we are not using the Backing Store we close the file
   PrintData(pageTable, buffer, len(logAddress))   # Prints statistics

# This makes sure that the main method will run
if __name__ == "__main__":
   main()

# End of Code
