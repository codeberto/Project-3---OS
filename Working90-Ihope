#!/usr/bin/env python

# Imported libraries
import sys
from sys import stdout

# Constants for the virtual memory program
FIFO = 0
LRU = 1
OPT = 2
MAX_TLB = 16
MAX_PAGES = 256
FRAMES = 256
CONTENT_SIZE = 256
DEFAULT_SCHED = 'FIFO'
MASK = 255
BYTE = 8
BACKING_STORE = 'BACKING_STORE.bin'

# The following will be classes that will be used in this code

# This is a basic page class that will be used as the simple structure
# that we can pass into other classes
class Page:
   def __init__(self):
      self.id = -1
      self.frame = -1
      self.used = 0
      self.loaded = False
   
   # accepts a frame and binds it to the page
   def setFrame(self, frame):
      self.frame = frame
      self.loaded = True
   
   # sets the unLoaded bit to false
   def unLoad(self):
      self.loaded = False

# This is the translation lookaside buffer and will hold only 16 spots
# for incoming pages
class TLB:
   def __init__(self, sched):
      self.table = [Page()] * MAX_TLB
      self.nextIndex = 0
      self.hits = 0
      self.misses = 0
      self.sched = sched
   
   # accepts a page id and returns whether or not it is in the TLB
   def lookup(self, id):
      status = False
      index = 0
      hitIndex = -1

      for entry in self.table:      # search through every element of TLB 
         if entry.id == id:
            hitIndex = index
            status = True
            self.hits += 1
         index += 1

      if self.sched == LRU:
        if status == True:                    
           hitPage = self.table.pop(hitIndex) # pop off hit page from current position
           self.table.append(hitPage)         # re-add it to the top of the stack (end of list)
                                              # this designates it as the most recently used item

      return status

   # accepts a page object, then adds it to the TLB according to the specified
   #    page replacement algorithm
   def add(self, page):
      self.misses += 1
      
      #FIFO add case
      if self.sched == FIFO:
         self.table[self.nextIndex] = page

         if self.nextIndex == MAX_TLB - 1:    # if at the end of the list
            self.nextIndex = 0                #   restart at beginning of list
         else:                                # else
            self.nextIndex += 1               #   keep going through the list
      
      #LRU add case
      if self.sched == LRU:
        if self.nextIndex == MAX_TLB:    # if full
          self.table.pop(0)              #   remove bottom of stack (first item added to list)
          self.table.append(page)        #   add new item to top of stack (end of list)

        else:
          self.table[self.nextIndex] = page # else, do a normal TLB add
          self.nextIndex += 1
   
   # accepts a page id and returns the frame associated with it
   def getFrame(self, id):
      frame = -1

      for entry in xrange(MAX_TLB):      # search through the TLB for the matching page
         if self.table[entry].id == id:
            frame = self.table[entry].frame

      return frame

   # accepts a frame and updates/unLoads the associated page's information
   # used when physical memory runs out of space and removes an entry 
   def updateFrame(self, frame):
      for entry in self.table:
         if entry.frame == frame:
            entry.frame = -1          # clears the associated frame variable from the page
            entry.unLoad()            # calls a function that resets the loaded bit

# All the pages are to be held in this data structure. Will not have
# pages initialized in the beginning. They have to be added in
class PageTable:
   def __init__(self):
      self.table = [Page()] * MAX_PAGES
      self.faults = 0

   # accepts a page object and adds it to the table
   def add(self, page):
      self.table[page.id] = page
      self.faults += 1

   # accepts a page id and returns whether or not it is in the table
   def lookup(self, pageID):
      status = False

      if self.table[pageID].id is not -1:
         status = True

      return status

   # accepts a page id and gets/returns the associated page object
   def getPage(self, pageID):
      return self.table[pageID]

   # accepts a frame number and updates/unLoads the associated page's information
   #  used when physical memory runs out and removes an entry
   def updateFrame(self, frame):
      for entry in self.table:
         if entry.frame == frame:
            entry.frame = -1
            entry.unLoad()

# This will act as actual physical memory and have content or data in
# the frames to be accessed
class PhysicalMem:
   def __init__(self, sched, frames):
      self.table = [0] * int(frames)
      self.frameOrder = [-1] * int(frames)
      self.sched = sched
      self.maxFrames = int(frames)
      self.currentFrame = 0
      self.nextFrame = 0

   # returns the next frame to write into, based on 
   #    available space and replacement algorithm
   def retNext(self):
     # FIFO return case
     if self.sched == FIFO:
        return self.nextFrame   # return the nextFrame
                                # determined by the PhysicalMem.add function
     # LRU return case
     if self.sched == LRU:
        if self.nextFrame == self.maxFrames - 1:   # if Physical memory is maxed out
           return self.frameOrder[0]               # return the least recently used frame
                                                   # determined by the frame Order stack
        else:
           return self.nextFrame                   # else return the next frame
                                                   # determined by the PhysicalMem.add function

   # accepts 'content' of int array type and binds the 'content' to the
   #    next available frame determined by the replacement algorithm
   def add(self, content):
      # FIFO add case
      if self.sched == FIFO:
         self.table[self.nextFrame] = content       
         self.currentFrame = self.nextFrame         

         if self.nextFrame == self.maxFrames - 1:  # if full
            self.nextFrame = 0                     #    restart at beginning
         else:                                     # else
            self.nextFrame += 1                    #    increment normally
      
      # LRU add case
      if self.sched == LRU:
         if self.currentFrame == self.maxFrames - 1:   # if full
            toReplace = self.frameOrder.pop(0)         #    get the index of the l.r.u. from the bottom of the order stack
            self.table[toReplace] = content            #    set the content at the retrieved index
            self.frameOrder.append(toReplace)          #    set the index to the most recently used (top of stack)
         else:                                         # else
            self.table[self.nextFrame] = content       #    add content normally
            self.currentFrame = self.nextFrame
            self.frameOrder.append(self.currentFrame)  #    add the current frame to the order stack

            if self.currentFrame != self.maxFrames - 1: # if not full after the add
               self.nextFrame += 1                      #   increment normally
        
   # accepts an frame index and returns the associated content
   def get(self, index):
     if self.sched == LRU:             # if LRU replacement algorithm is set
        self.frameOrder.remove(index)  #   remove the index from the stack
        self.frameOrder.append(index)  #   then re-add it to the top of the stack
     return self.table[index]


# The following are functions to be used in the code

# This function takes arguments in and returns them in a format we can use.
# This assumes that all args are in the correct position
def ReturnArgs(args):
   filename = ''
   frames = FRAMES
   pra = DEFAULT_SCHED

   if len(args) > 0:
      filename = args[0]

      if len(args) == 3:        # if all 3 arguments are given
         frames = args[1]    
         pra = args[2]
      elif len(args) == 2:      # if only 2 arguments are given
         if args[1].isdigit():  #   check if the second argument is a number 
            frames = args[1]
         else:
            pra = args[1]

   return (filename, frames, pra)

# Opens the file passed in with a try except method. Takes all the data
# from that file and closes it.
# This also opens the backing store file
def OpenFiles(logAddress, filename):
   try:
      with open(filename, 'r') as file:
         for line in file:
            logAddress.append(int(line))

      file.close()
   except IOError as e:
      print 'I/O error, file does not exist'
      sys.exit()

   binFile = open(BACKING_STORE)

   return binFile

# Sets the scheduling type for physical memory and the tlb
def SetSched(pra):
   sched = FIFO

   if pra.upper() == 'LRU':
      sched = LRU
   elif pra.upper() == 'OPT':
      sched = OPT

   return sched

# Gets the page info as well as the offset of an address
def GetInfo(address):
   page = (MASK << BYTE & address) >> BYTE
   offset = MASK & address

   return (page, offset)

# Looks at a 256 byte hex value and gets the byte located at the offset
# Prints in signed 8 bit integer
def GetValue(content, offset):
   decoded = content.decode('hex')  # Transformes a hex value to be readable as a decimal
   value = ord(decoded[offset])  # Gets the byte from the specified offset

   # This makes sure that the output can be viewed as a 8 bit signed integer
   if value >= (CONTENT_SIZE / 2):
      value = value - CONTENT_SIZE

   return value

# Gets a 256 byte value from the backing store
def GetContent(binFile, page):
   position = page * CONTENT_SIZE
   file = binFile
   file.seek(position)
   content = file.read(256)
   content = content.encode('hex').upper()
   return content

# Prints the data of the code to stdout
def PrintData(pageTable, tlb, length):
   faults = pageTable.faults

   print('Number of Translated Addresses = %d' %length)
   print('Page Faults = %d' %faults)
   print('Page Fault Rate = %.3f' %(float(faults) / float(length)))
   print('TLB Hits = %d' %(tlb.hits))
   print('TLB Misses = %d' %(tlb.misses))
   print('TLB Hit Rate = %.3f' %(float(tlb.hits) / (float(tlb.hits) + float(tlb.misses))))

# Main function of the code. Will drive the functions in order to complete
# the fake virtual memory code
def main():
   args = sys.argv[1:]  # This will have all the arguments that we will use
   logAddress = []      # Will have all logical addresses
   filename, frames, pra = ReturnArgs(args)  # Gives us all the arguments
   binFile = OpenFiles(logAddress, filename) # Moves file contents to logAddress and opens backing store

   sched = SetSched(pra)   # Sets the schedule. We will use for tlb and physical mem
   buffer = TLB(sched)     # Sets up the TLB
   pageTable = PageTable() # Sets up the page table
   physicalMem = PhysicalMem(sched, frames)  # Sets up physical memory

   # Goes through all the logical addresses, Virtual Memory to Physical Memory part of the main
   for address in logAddress:
      pageID, offset = GetInfo(address)   # Gets the page and offset from the logical address
      newPage = Page()
      newPage.id = pageID
      frameNum = physicalMem.retNext()    # Value will never get used. Put here to handle an error

      # First checks to see if in the buffer to set frame
      if not(buffer.lookup(pageID)):
         # If not in the buffer checks to see if page is in the pageTable. Adds to buffer if yes

         # need to add check for whether page is loaded or not loaded
         if pageTable.lookup(pageID):
            pageTemp = pageTable.getPage(pageID)
            buffer.add(pageTemp)
         # Adds page to TLB and pagetable if not found. Then adds to pysical memory
         else:
            newPage.setFrame(physicalMem.retNext())   # Based on the scheduling algorithm set new frame
     
            pageTable.updateFrame(physicalMem.retNext())  # makes sure the designated next frame is not already bound 
            buffer.updateFrame(physicalMem.retNext())     #   in either the TLB or the page Table

            buffer.add(newPage)
            pageTable.add(newPage)

            physicalMem.add(GetContent(binFile, pageID))
      else:
         frameNum = buffer.getFrame(pageID)  # To access physical memory framenumber

      frameNum = buffer.getFrame(pageID)  # Could be accessed through other means but this supports
                                          # and mimics how virtual memory really moves around
      # The following just prints out necessary information for each logical address
      stdout.write('%d, ' %address)
      stdout.write('%d, ' %GetValue(physicalMem.get(frameNum), offset))
      stdout.write('%d, ' %frameNum)
      stdout.write(physicalMem.get(frameNum))
      stdout.write('\n')
      stdout.flush()

   binFile.close()   # Now that we are not using the Backing Store we close the file
   PrintData(pageTable, buffer, len(logAddress))   # Prints statistics

# This makes sure that the main method will run
if __name__ == "__main__":
   main()

# End of Code
