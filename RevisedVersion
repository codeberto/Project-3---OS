#!/usr/bin/env python

# Imported libraries
import sys
from sys import stdout

# Constants for the virtual memory program
FIFO = 0
IRU = 1
OPT = 2
MAX_TLB = 16
MAX_PAGES = 256
FRAMES = 256
CONTENT_SIZE = 256
DEFAULT_SCHED = 'FIFO'
MASK = 255
BYTE = 8
BACKING_STORE = 'BACKING_STORE.bin'

# The following will be classes that will be used in this code

# This is a basic page class that will be used as the simple structure
# that we can pass into other classes
class Page:
   def __init__(self):
      self.id = -1
      self.frame = -1
      self.loaded = False
   def setFrame(self, frame):
      self.frame = frame
      self.loaded = True
   def unLoad(self):
      self.loaded = False

# This is the translation lookaside buffer and will hold only 16 spots
# for incomming pages
class TLB:
   def __init__(self, sched):
      self.table = [Page()] * MAX_TLB
      self.nextIndex = 0
      self.hits = 0
      self.misses = 0
      self.sched = sched

   def lookup(self, id):
      status = False

      for entry in self.table:
         if entry.id == id:
            status = True
            self.hits += 1

      return status

   def add(self, page):
      self.misses += 1

      if self.sched == FIFO:
         self.table[self.nextIndex] = page

         if self.nextIndex == MAX_TLB - 1:
            self.nextIndex = 0
         else:
            self.nextIndex += 1

   def getFrame(self, id):
      frame = -1

      for entry in xrange(MAX_TLB):
         if self.table[entry].id == id:
            frame = self.table[entry].frame

      return frame

class PageTable:
   def __init__(self):
      self.table = [Page()] * MAX_PAGES
      self.faults = 0

   def add(self, page):
      self.table[page.id] = page
      self.faults += 1

   def lookup(self, pageID):
      status = False

      if self.table[pageID].id is not -1:
         status = True

      return status

   def getPage(self, pageID):
      return self.table[pageID]

class PhysicalMem:
   def __init__(self, sched, frames):
      self.table = [0] * frames
      self.sched = sched
      self.maxFrames = frames
      self.currentFrame = 0
      self.nextFrame = 0

   def add(self, content):
      if self.sched == FIFO:
         self.table[self.nextFrame] = content
         self.currentFrame = self.nextFrame

         if self.nextFrame == self.maxFrames - 1:
            self.nextFrame = 0
         else:
            self.nextFrame += 1

   def get(self, index):
      return self.table[index]

# This function takes arguments in and returns them in a format we can use.
# This assumes that all args are in the correct position
def ReturnArgs(args):
   filename = ''
   frames = FRAMES
   pra = DEFAULT_SCHED

   if len(args) > 0:
      filename = args[0]

      if len(args) == 3:
         frames = args[1]
         pra = args[2]
      elif len(args) == 2:
         if args[1].isdigit():
            frames = args[1]
         else:
            pra = args[1]

   return (filename, frames, pra)

# Opens the file passed in with a try except method. Takes all the data
# from that file and closes it.
# This also opens the backing store file
def OpenFiles(logAddress, filename):
   try:
      with open(filename, 'r') as file:
         for line in file:
            logAddress.append(int(line))

      file.close()
   except IOError as e:
      print 'I/O error, file does not exist'
      sys.exit()

   binFile = open(BACKING_STORE)

   return binFile

# Sets the scheduling type for physical memory and the tlb
def SetSched(pra):
   sched = FIFO

   if pra.upper() == 'IRU':
      sched = IRU
   elif pra.upper() == 'OPT':
      sched = OPT

   return sched

# Gets the page info as well as the offset of an address
def GetInfo(address):
   page = (MASK << BYTE & address) >> BYTE
   offset = MASK & address

   return (page, offset)

def GetValue(content, offset):
   decoded = content.decode('hex')
   value = ord(decoded[offset])

   if value > ((CONTENT_SIZE / 2) + 1):
      value = value - CONTENT_SIZE

   return value

def GetContent(binFile, page):
   position = page * CONTENT_SIZE
   file = binFile
   file.seek(position)
   content = file.read(256)
   content = content.encode('hex').upper()
   return content

# Prints the data of the code to stdout
def PrintData(pageTable, tlb, length):
   faults = pageTable.faults

   print('Number of Translated Addresses = %d' %length)
   print('Page Faults = %d' %faults)
   print('Page Fault Rate = %.3f' %(float(faults) / float(length)))
   print('TLB Hits = %d' %(tlb.hits))
   print('TLB Misses = %d' %(tlb.misses))
   print('TLB Hit Rate = %.3f' %(float(tlb.hits) / (float(tlb.hits) + float(tlb.misses))))

# Main function of the code. Will drive the functions in order to complete
# the fake virtual memory code
def main():
   args = sys.argv[1:]
   logAddress = []
   filename, frames, pra = ReturnArgs(args)  # Gives us all the arguments
   binFile = OpenFiles(logAddress, filename)

   sched = SetSched(pra)
   buffer = TLB(sched)
   pageTable = PageTable()
   physicalMem = PhysicalMem(sched, frames)

   for address in logAddress:
      pageID, offset = GetInfo(address)
      newPage = Page()
      newPage.id = pageID
      frameNum = physicalMem.nextFrame

      if not(buffer.lookup(pageID)):
         if pageTable.lookup(pageID):
            pageTemp = pageTable.getPage(pageID)
            buffer.add(pageTemp)
            frameNum = pageTemp.frame
         else:
            newPage.setFrame(physicalMem.nextFrame)
            buffer.add(newPage)
            pageTable.add(newPage)
            physicalMem.add(GetContent(binFile, pageID))
      else:
         frameNum = buffer.getFrame(pageID)

      stdout.write('%d, ' %address)
      stdout.write('%d, ' %GetValue(physicalMem.get(physicalMem.currentFrame), offset))
      stdout.write('%d, ' %frameNum)
      stdout.write(physicalMem.get(physicalMem.currentFrame))
      stdout.write('\n')
      stdout.flush()

   binFile.close()
   PrintData(pageTable, buffer, len(logAddress))

# This makes sure that the main method will run
if __name__ == "__main__":
   main()

# End of Code
